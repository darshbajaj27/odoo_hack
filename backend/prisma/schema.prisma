generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS ---

enum UserRole {
  MANAGER
  STAFF
}

enum UserStatus {
  ACTIVE
  INACTIVE
}

enum LocationType {
  INTERNAL
  VENDOR
  CUSTOMER
  INVENTORY_LOSS
}

enum OperationType {
  RECEIPT
  DELIVERY
  INTERNAL
  ADJUSTMENT
}

enum OperationStatus {
  DRAFT
  WAITING
  READY
  DONE
  CANCELLED
}

enum ContactType {
  VENDOR
  CUSTOMER
}

// --- MODELS ---

model User {
  id         Int        @id @default(autoincrement())
  email      String     @unique
  password   String
  name       String
  role       UserRole   @default(STAFF)
  status     UserStatus @default(ACTIVE)
  avatar     String?

  // Password reset
  otpSecret  String?
  otpExpires DateTime?

  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  @@map("users")
}

model Warehouse {
  id        Int      @id @default(autoincrement())
  name      String
  shortCode String   @unique // e.g., "SF"
  address   String

  locations Location[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("warehouses")
}

model Location {
  id                Int          @id @default(autoincrement())
  name              String       // e.g., "WH/Stock", "Partner Locations/Vendors"
  type              LocationType
  
  // Parent Warehouse (Optional because Vendor locations might not be in your warehouse)
  parentWarehouseId Int?          
  parentWarehouse   Warehouse?   @relation(fields: [parentWarehouseId], references: [id], onDelete: Cascade)

  // RELATIONS
  stockItems        StockItem[]  // Tracks what is inside this location
  
  sourceOperations      Operation[] @relation("SourceLocation")
  destinationOperations Operation[] @relation("DestinationLocation")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("locations")
}

model Product {
  id           Int     @id @default(autoincrement())
  sku          String  @unique
  name         String
  category     String
  
  // "Cached" totals (calculated from StockItems) for fast Dashboard loading
  onHand       Float   @default(0) 
  freeToUse    Float   @default(0)
  
  costPrice    Float   @default(0)
  sellingPrice Float   @default(0)

  // RELATIONS
  stockItems     StockItem[]     // Tracks where this product lives
  operationLines OperationLine[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("products")
}

// This tracks exactly how much of Product X is at Location Y
model StockItem {
  id        Int     @id @default(autoincrement())
  quantity  Float   @default(0)

  productId Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  locationId Int
  location   Location @relation(fields: [locationId], references: [id], onDelete: Cascade)

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Ensures you can't have two rows for "Steel Rod" at "Shelf A". 
  // Instead, you update the quantity of the single row.
  @@unique([productId, locationId]) 
  @@map("stock_items")
}

model Contact {
  id        Int         @id @default(autoincrement())
  name      String
  type      ContactType
  email     String?

  operations Operation[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("contacts")
}

// The "Double-Entry Ledger"
model Operation {
  id             String          @id // Manual ID like "WH/IN/0001"
  ref            String?         // External Ref like "PO/001"
  type           OperationType
  status         OperationStatus @default(DRAFT)
  scheduledDate  DateTime
  
  contactId      Int?
  contact        Contact?        @relation(fields: [contactId], references: [id], onDelete: SetNull)

  sourceLocationId      Int
  sourceLocation        Location @relation("SourceLocation", fields: [sourceLocationId], references: [id], onDelete: Restrict)

  destinationLocationId Int
  destinationLocation   Location @relation("DestinationLocation", fields: [destinationLocationId], references: [id], onDelete: Restrict)

  lines          OperationLine[]

  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  @@map("operations")
}

model OperationLine {
  id          Int       @id @default(autoincrement())
  
  operationId String
  operation   Operation @relation(fields: [operationId], references: [id], onDelete: Cascade)

  productId   Int
  product     Product   @relation(fields: [productId], references: [id], onDelete: Restrict)

  demandQty   Float
  doneQty     Float     @default(0)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("operation_lines")
}